# URL_Status_Checker
<h1> 
<p align="center" >Python-flask-mongo-selenium-swagger for checking the status of a url and its hyperlinks</h1>

## Problem Statement:
Write a program that visits a particular url. It then finds all the hyperlinks on that page, visits them and checks whether those hyperlinks are alive or dead.Also Capture the below fields  in any database.
    Schema - (Sr No., Domain Name,Url,Status Code,Response Time)
    Note:- Give configuration variable as depth.
    Host this in a cloud platform with some frontend.
    Example Url:- https://www.flipkart.com/
## Steps for setting up the virtual environment using anaconda: 
The python version used for this project is 3.6.

    conda create -n envname python=3.6
    conda activate envname

## Complete Requirements for the project:
The following are the libraries required to run this project.

    pip install shapely
    pip install imagecodecs
    pip install pyvips
    pip install numpy
    pip install pandas
    pip install glob
    pip install sklearn
    pip install matplotlib
    pip install h5py
    pip install opencv-python
    pip install mahotas
    pip install skimage
    pip install scipy==1.1.0
    pip install shutil
    pip install joblib
    pip install sklearn
    pip install git+https://github.com/vatsalsaglani/xrayimage_extractfeatures.git 
    pip install pickle

* **Download Groovy**:

[Groovy](https://groovy-lang.org/install.html)

* **Download Qupath-Gui Tool**:

[Qupath](https://github.com/qupath/qupath/wiki/Installing-QuPath)

## Instructions to run the code:

1. Open Qupath and create a project by adding the .scn sample file to the project(Choose rotate 90 degree option at the time of uploading the sample).

<img alt="Image" src="images/qupath1.png" width=500px height=400px align="center">


2. Mark the rectangular area using the rectangle icon located on the top right corner.(The entire analysis will be done on this selected area).

<img alt="Image" src="images/qupath2.png" width=500px height=400px align="center">


3. Open script editor, drag and drop the scripts and run them based on the usecase. 


## Groovy Scripts:

* **ValidationLabelledAnnotations.groovy**: To display the annotationed xml file in Qupath
* **Validation.groovy**: This script is used when you have the ground truth.
* **Testing.groovy**: This script is used when you want to do the prediction.
* **Boundingboxes.groovy**: For displaying the bounding boxes after prediction

<h2>Preprocessing Steps</h2>

* Tile generation
* Tile labelling
* XML Generation

## Requirements:
You are required to be running python3. In addition, install the following libraries:

    pip install shapely
    pip install imagecodecs
    pip install pyvips
    pip install numpy
    pip install pandas

## Input Format
Expected format of input file:
* line 1: Name of .scn whole slide image file
* line 2: Name of .xml annotation file
* line 3: 4 space separated float values representing top-left x-y pair and bottom right x-y pair of the rectangular region we want to tile
* line 4: tilesize

## Packages

### Classes
This package has the following modules:
* **ellipse.py**: Contains the class for the geometric figure of ellipse.
* **polygon.py**: Contains the Class for the geometric figure of a general polygon with a variable number of straight edges.
* **rectangle.py**: This class inherits from Polygon.
* **tile.py**: This class also inherits from Polygon. However, in addtion to the base functionality provided by the Polygon class, the Tile class can check whether it intersects, lies outside, lies inside a Polygon/Ellipse or if the Polygon/Ellipse lies completely inside the tile itself.

### Visualize
This package, as the name suggests, aids in visualization:
* **parseXML.py**: This file takes in an XML file generted from ImageScope and converts it into a .txt file with the columns - type of polygon, annotation name, followed by a series of vertices as x,y pairs. It is assumed that the first annotation in this file corresponds to the bounding box (region of interest) that we are considering, within which the other polygon/ellipse annotations of intersect are present.

* **genTilesForRoi.py**: This file takes the .txt file generated by parseXML.py and generates the tiles (provided the tilesize). 

* **labelStatus.py**: This file takes the tiles of interest and updates the status of the tiles with respect to a given annotation.
Status here indicates whether:
  * the tile lies completely inside the annotation(Which will be defined using the label: 0).
  * The tile intersects the annotation(Which will be defined using the label: 1).
  * The annotation lies completely inside the tile(Which will be defined using the label: 3).

* **createXML.py**: This file takes the tiles, annotations and generates an XML file to view as an overlay on WSI images in Qupath.

* **extractDetails.py**: This function parses the input file to provide an array of relevant information in the required formats.

* **visualizeTiles.py**: Provides a class that serves as a wrapper around all the other files in this package.

<h2>Prediction</h2>

## Requirements:
You are required to be running python3. In addition, install the following libraries:

    pip install numpy
    pip install pandas
    pip install glob
    pip install sklearn
    pip install matplotlib
    pip install h5py
    pip install opencv-python
    pip install mahotas
    pip install skimage
    pip install scipy==1.1.0
    pip install shutil
    pip install joblib
    pip install sklearn
    pip install git+https://github.com/vatsalsaglani/xrayimage_extractfeatures.git 
    pip install pickle

* **Validation.py**: This file takes the all the generated tiles and pass these tiles through the predictor.
This is a binary classification problem.And here we have to identify whether the tile is Necrotic or not.

Labels used for denoting the tiles:

* Necrosis - 1
* Non-Necrosis -0

Based on the prediction and the original label(ground truth) we will classify the tiles into : 

1. True Positive - Predicting necrosis tiles as necrosis
2. True Negative - Predicting non-necrosis tiles as non-necrosis tiles
3. False Positive - Predicting the non-necrosis tiles  as necrosis tiles
4. False Negative - Predicting the necrosis tiles as non-necrosis tiles

Using the above key-value pairs we will create a dataframe and generate a csv file.

Using this csv file an xml file wil be generated which is used for visualization on Qupath.

* **Testing.py**: This file takes the all the generated tiles and pass these tiles through the predictor.

This is a binary classification problem.And here we have to identify whether the tile is Necrotic or not.

Labels used for denoting the tiles:

* Necrosis - 1
* Non-Necrosis - 0

Using the above key-value pairs we will create a dataframe and generate a csv file.

Using this csv file an xml file wil be generated which is used for visualization on Qupath.

* **Note**: The key difference between Validation and Testing is we will be having the groundtruth for validation and no ground truth for the testing.

* **Color Notations for visualization of bounding boxes**:

* Validation:

    1. True Positive - Green 
    2. True Negative - Red
    3. False Positive - Blue
    4. False Negative - Black

* Testing:

    1. prediction yes - green (Necrotic tiles)
    2. prediction no -  red (Non-Necrotic tiles)



